\chapter{Introduction}

In configurable software systems that need to meet a wide range of customer requirements, variability is of great 
importance. Understanding variable software is essential for its evolution, and there are several approaches for 
dealing with the analysis of variable software systems. One important application of program analysis is change impact 
analysis (CIA), the identification of the potential consequences of a change. An approach for change impact analysis of 
configurable software was developed by Angerer et al.\ \cite{DBLP:conf/kbse/AngererGPG15}. This approach uses a system 
dependence graph to represent the whole program.

A system dependence graph (SDG), introduced by Horwitz et al.\ \cite{DBLP:journals/toplas/HorwitzRB90}, encodes all 
control and data dependencies in a whole program. An extension is the conditional system dependence graph (CSDG) 
introduced by Angerer et al.\ \cite{DBLP:conf/splc/AngererPLGG14}, which also represents variability information in the 
program. The SDG represents procedures by their program dependence graphs (PDGs). A PDG consists of a node for the 
procedure itself, a number of formal parameter nodes for parameters and global variables used in the procedure, and 
nodes for every statement in the procedure. The nodes are connected by edges representing the control and data 
dependencies inside the procedure. The SDG also represents the dependencies between procedures in the whole program, 
based on one or more entry points into the program. The SDG is instance-based, which means, in object-oriented terms, 
that for multiple instances of a class, a method called on different instances will be represented in the SDG by 
distinct instances of the method's PDG.

Since SDGs can get very large---many hundreds of thousands of nodes 
\cite[sec.~4.3]{DBLP:conf/splc/AngererPLGG14}---using them for manual analysis in their entirety is impossible. There 
are however a number of use cases where one would want to explore the SDG of a system manually, for example the 
aforementioned change impact analysis.


\section{Static Analysis}

System dependence graphs are constructed based on the source code of a whole program through static program analysis. 
This means it is not necessary to run a program for analyzing it, but it also means that the analysis cannot use any 
information which might only be available at runtime.

In the concrete case of building an SDG, the major downside of using static analysis is that information about object 
instances needs to be extracted from the source code alone, which might not be easy or at all possible. For example, in 
languages like Java that support dynamic allocation of objects, complicated points-to analysis is necessary to 
determine which object instances might exist, and then the result may still be inaccurate.

This is however not a problem with the IEC 61131-3 family of languages~\cite{IEC61131:2003} used in this thesis, as 
they don't support dynamic allocation. An instance in those languages is statically allocated by defining a variable of 
a particular type. This makes it possible to statically determine all instances of objects that will exist at runtime, 
which is necessary to determine the instances of graph elements needed for the SDG.


\section{The Tool}

The tool developed in this thesis (the \emph{\SB}) implements interactive exploration of an SDG based on a chosen entry 
point. An entry point can be---depending on the use case---a single statement, a procedure, or a variable. Based on the 
selected entry point, control and data edges in the graph can be followed interactively. The tool was developed with a 
number of use cases in mind.

\begin{description}
  \item[Executions] Determine through which paths a statement or procedure can be executed. This effectively gives a 
  graph which contains all possible stack traces that could be observed for any execution.
  
  \item[Variable Assignment] Determine all statements that write to a particular variable (including procedure 
  parameters), and for those statements show their \emph{Executions}.
  
  \item[Change Impact] For any program element (statement, procedure, variable) determine other statements or variables 
  possibly affected by its change or execution. This can be used to determine whether a particular change will have any 
  unforeseen consequences.
  
  \item[Change Cause] This is basically an inverse change impact analysis, which for any program element determines 
  other statements or variables which might have an impact on its value or execution.
\end{description}

The \SB was developed in the course of our cooperation with Keba AG\footnote{\url{http://www.keba.com}} through the 
Christian Doppler Laboratory on Monitoring and Evolution of Very-Large-Scale Software Systems (CDL MEVSS for short).
\enquote{Keba AG is a medium-sized company developing and producing tools, hardware, and software for the industrial 
automation domain. An example system is KePlast, a comprehensive solution for the automation of injection molding 
machines. The core of KePlast is a configurable control software framework which is implemented in a proprietary 
dialect of the IEC 61131-3, a widely-adopted programming language standard for implementing industrial automation 
systems.}~\cite[sec.~3.1]{DBLP:conf/splc/AngererPLGG14}

The versions of the SDG and \SB introduced in this thesis work with the IEC 61131-3 languages only, because this was 
the initial target of Florian Angerer's PhD work. However there is ongoing work to support analysis across language 
boundaries~\cite{DBLP:conf/kbse/Angerer14}.


\section{Outline}

The remainder of the thesis is organized as follows.
\Chapref{ch:sdg} will cover the SDG in more detail and explain its structural properties.
In \autoref{ch:usecases} the use cases targeted by the \SB implementation will be introduced.
A tutorial and user's manual on using the \SB, based on the use cases defined earlier, will be given in 
\autoref{ch:manual}.
\Chapref{ch:impl} will explain some of the implementation in detail and serve as an introduction to the system for 
future developers.
Finally, \autoref{ch:related} will give a short overview of related work and \autoref{ch:summary} will conclude the 
thesis.
